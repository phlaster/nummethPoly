\documentclass[a4paper, 14pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{setspace}
\setstretch{1.3}
\usepackage{anyfontsize}
\usepackage{amsmath, amsfonts, amssymb, amsthm, mathtools}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{breqn}
\include{settings}
\begin{document}
\include{titlepage}
\pagenumbering{arabic}
\setcounter{page}{2}
\tableofcontents
\clearpage

\section{Теоретическое описание}

\subsection{Метод прямоугольников с заданным числом разбиений}

Наиболее прямолинейным численным методом расчёта интегральной суммы является метод прямоугольников. Разбивая исследуемый отрезок $[a,b]$ на $n$ равных
\footnote{что, впрочем, не обязательно в общем случае}
кусочков длины $h = (b-a)/n$ вычисляем на каждом из них в точке
\footnote{в общем случае -- произвольной}
$\xi_i$ значение подынтегральной функции $f(\xi_i)$ составляют сумму:

\begin{equation}
    I^r = \sum_{i=1}^{n}f(\xi_i)(x_i-x_{i-1})
\end{equation}

Которая в пределе стремится к точному значению определённого интеграла:

\begin{equation}
    \lim_{n\to\infty}I^r = I
\end{equation}

Для монотонных функций показано, что если выбирать каждый раз крайнюю точку разбиения за $\xi_i$, то $I_n$ будет вычисляться соответственно с избытком/недостатком, в зависимости от возрастания/убывания монотонной функции на отрезке. Рационально выбирать среднюю точку каждого отрезка разбиения, что реализовано в базовом методе расчёта интегральной суммы.

\subsubsection{Алгоритм}
\begin{enumerate}
    \item Разбить выбранный участок $[a,b]$ на $n$ частей точками $x_i$ с шагом $h=\dfrac{b-a}{n}$:$$
    x_0=a,~~~x_i=x_{i-1}+h|_{i=1,2,3,...n-1},~~~ x_n=b;$$

    \item Выбрать $\xi_i$. Для средней точки взять $\xi_i=\dfrac{x_{i-1}+x_i}{2};$

    \item Произвести расчёт:
    \begin{equation}
        I\approx I^\Pi := h\sum_{i=1}^{n}f(x_i-\dfrac{h}{2});
    \end{equation}
\end{enumerate}

\subsection{Метод трапеций с заданным числом разбиений}
Логическим развитием метода прямоугольников стал метод трапеций. Геометрически он разбивает подынтегральную площадь на трапеции с вершинами в точных значениях исследуемой функции.

\subsubsection{Алгоритм трапеций}
\begin{enumerate}
    \item Разбить выбранный участок $[a,b]$ на $n$ частей точками $x_i$ с шагом $h=\dfrac{b-a}{n}$:$$
    x_0=a,~~~x_i=x_{i-1}+h|_{i=1,2,3,...n-1},~~~ x_n=b;$$

    \item Произвести расчёт:
    \begin{equation}
        I\approx I^T := h\left( \dfrac{f(x_0)+f(x_n)}{2} + \sum_{i=1}^{n-1}f(x_i)\right) ;
    \end{equation}
\end{enumerate}

\paragraph{Применимость методов}
\begin{itemize}
    \item Функция задана аналитически;

    \item Функция ограничена на отрезке;

    \item Функция имеет на отрезке не более чем конечное число разрывов первого рода;
\end{itemize}


\subsection{Метод трапеций с заданной точностью}
\label{sec:trapez_runge}

Вместо заранее заданного количества шагов удобнее задавать требуемую точность. Тогда итерационный процесс должен быть остановлен автоматически исходя из формального критерия. Таким критерием может служить принцип Рунге, оценивающий разницу между значениями интегральной суммы на $n$ и $2n$ разбиениях:

\begin{equation}
    \Delta_{2n} \approx \Theta \left|I_{2n} - I_n\right|;~~~\Theta=\dfrac{1}{2^p-1}
\end{equation}

Коэффициент $\Theta$ зависит от порядка погрешности использованного численного метода. Для левых и правых прямоугольников: $\Theta=1$, для средних прямоугольников и трапеций: $\Theta=\frac{1}{3}$, для формулы Симпсона: $\Theta=\frac{1}{15}$.

\subsubsection{Алгоритм с использованием критерия Рунге}
\begin{enumerate}
    \item Выбрать необходимую точность $\varepsilon$, положить $n:=1$, рассчитать $I_n$;

    \item Произвести расчёт используемым методом по $2n$ точкам: $I_{2n}$

    \item Воспользоваться принципом Рунге с учётом подходящего методу коэффициента $\Theta$:
    Если $\Theta \left|I_{2n} - I_n\right| \le \varepsilon \implies \blacksquare$

    \item $n:= 2n$, вернуться к 2.
\end{enumerate}

\subsection{Адаптивный метод с заданной точностью}

Однако каждый раз удваивать мелкость дробления на всём отрезке может показаться слишком расточительно. Поскольку общая ошибка интегральной суммы $n$ слагаемых складывается из локальных ошибочек каждого слагаемого:

\begin{equation}
    \varepsilon \equiv \varepsilon\cdot\sum_{i=1}^{n} (x_{i-1}, x_i)
\end{equation}
Будем следить за ошибкой на каждом отрезке и выборочно дробить только те -- на которых ошибка больше отведённой ей доли. Для этого используем рекурсивный алгоритм.

\subsubsection{Алгоритм адаптивного метода}
\begin{enumerate}
    \item До входа в рекурсию положить $n:=1$, выбрать необходимую точность $\varepsilon,~~~a_k := a, ~~~b_k := b$;

    \item Вход в рекурсию \begin{enumerate}
        \item Положить $h:=b_k-a_k$, рассчитать выбранным методом $I_1$, $I_2$ и  $\Delta = \Theta\left|I_2 - I_1\right|$ для подходящей $\Theta$;
        \item Условие выхода из рекурсии $\Delta \le \varepsilon\cdot\dfrac{h}{2} ~~~ \implies n:=n+1; ~~~ \implies \text{ вернуть } I_2$
        \item Рекурсивный вызов: вернуть сумму результата входа в рекурсию (2) для $\begin{cases}
            a_k:=a_k;~~ b_k:= \dfrac{a_k+b_k}{2}\\
            a_k:=\dfrac{a_k+b_k}{2};~~ b_k:=b_k \\
        \end{cases}$
    \end{enumerate}
\end{enumerate}


\section{Тестовый пример}
\begin{equation}
    \text{Вариант 23:}~~~~~f(x) = x^5 - 3.2x^3 + 9.5x^2 - 7x - 7.5,~~~~~~x \in [-0.7, 1.6]
\end{equation}
\subsection{Метод трапеций с заданной точностью}

\begin{enumerate}
    \item $a:= -0.7,~~~b:=1.6$
    \item
    \begin{enumerate}
        \item $n:=1, ~~~ h:=\dfrac{b-a}{n}=2.3$
        \item $x_0 = -0.7, ~~ x_1 = 1.6$
        \item $I_1 = h(\dfrac{f(x_0)+f(x_1)}{2}) = 6.88$
    \end{enumerate}

    \item
    \begin{enumerate}
        \item $n:=2, ~~~ h:=\dfrac{b-a}{2}=1.15$
        \item $x_0,...,x_2 = \{-0.7, 0.45, 1.6\}$
        \item $I_2 = h(\dfrac{f(x_0)+f(x_2)}{2} + f(x_1)) = -6.91$
    \end{enumerate}
    \item $\Delta_{1-2} = 1/3 \cdot |I_2 - I_1| = \mathbf{4.60}$

    \item
    \begin{enumerate}
        \item $n:=2, ~~~ \text{ с прошлого шага: } \implies I_2 = -6.91$
    \end{enumerate}

    \item
    \begin{enumerate}
        \item $n:=4, ~~~ h:=\dfrac{b-a}{4}=0.56$
        \item $x_0,...,x_5 = \{ -0.7,-0.13,0.45,1.03,1.6\}$
        \item $I_4 = h(\dfrac{f(x_0)+f(x_5)}{2} + f(x_1)+f(x_2)+f(x_3)+f(x_4)) = -11.15$
    \end{enumerate}
    \item $\Delta_{2-4} = 1/3 \cdot |I_4 - I_2| = \mathbf{1.42}$

    \begin{enumerate}
        \item $n:=4, ~~~ \text{ с прошлого шага: } \implies I_4 = -11.15$
    \end{enumerate}

    \item
    \begin{enumerate}
        \item $n:=8, ~~~ h:=\dfrac{b-a}{8}=0.28$
        \item $x_0,...,x_8 = \{  -0.7,-0.41,-0.13,0.16,0.45,0.74,1.03,1.31,1.6\}$
        \item $I_8 = h(\dfrac{f(x_0)+f(x_8)}{2} + f(x_1)+f(x_2)+f(x_3)+f(x_4)+f(x_5)+f(x_6)+f(x_7)) = -12.33$
    \end{enumerate}
    \item $\Delta_{4-8} = 1/3 \cdot |I_8 - I_4| = \mathbf{0.39}$

\end{enumerate}

\subsection{Модульная структура}
\lstinputlisting[language=C++]{listings/header.hpp}
\paragraph{Комментарий:} Вместо возвращения числа шагов последняя функция принимает указатель на глобальную целочисленную переменную, такой подход упрощает расчёт шагов внутри рекурсивных вызовов.

\section{Исследование сходимости}
\begin{figure}[H]
    \centering
    \caption{Зависимость фактической точности от количества отрезков разбиения}
    \includegraphics[width=1\linewidth]{images/only}
    \label{fig:1}
\end{figure}
Рисунки показывают, что все исследованные методы имеют одинаковые порядки сходимости. Добавление проверки критерия Рунге никак не влияет на сходимость метода, но служит для автоматизации подбора необходимой мелкости разбиения отрезка интегрирования для достижения желаемой точности.

На рисунке видим параллельное смещение графика зависимости шагов от точности адаптивного метода вниз. Это означает, что хотя степени сходимости методов совпадают, они различаются константами. Действительно, исходя из описанное алгоритма, там, где обычный метод трапеций на каждом шаге удваивает измельчение на всём интервале интегрирования, измельчение в адаптивном методе происходит только на тех интервалах, на которых оно лучше всего снизит ошибку. Это приводит к снижению общего числа слагаемых в интегральной сумме, то есть адаптивный метод успеет показать лучшую точность перед тем, как вступит неизбежная ошибка суммирования.

В целом же, всеми исследованными методами машинная точность оказалась недостижима именно по причине нарастания ошибки суммирования большого количества чисел с плавающей точкой. Для повышения точности следует использовать более совершенные методы, например метод Симпсона.



\end{document}