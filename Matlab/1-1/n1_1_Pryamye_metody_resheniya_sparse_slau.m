clc;
% БАЗА (0)
% 1. Создание симметричных ПО матриц разреженной структуры.
% 1.1. Создать матрицу:
a = [10 0 0;
     0 0 20;
     30 40 0];

% 1.2. Преобразование полной матрицы в разреженную:
sA1 = sparse(a);

% 1.3. Создание разреженной матрицы:
sA2 = sparse([1 3 3 2],  [1 1 2 3], [10 30 40 20], 3, 3);

% 1.4. Преобразование разреженной матрицы в обычную:
a2 = full(sA2);

% 1.5. Создание случайной разреженной матрицы:
sB1 = sprand(5, 5, 0.1);

% 1.6. Создание диагоналей разреженной матрицы:
E = ones(10,1);
D = spdiags(-E, 0, 10, 10);

% 1.7. Создание разреженной единичной матрицы:
sE = speye(10);

% 1.8. Создание симметричной ПО разреженной матрицы:
sB2 = sprandsym(10, 1/30, 0.8, 1);

% 1.9. Создание симметричной ПО матрицы по формуле:
B = sprand(7,7, 0.1); % случайная
A = B + B' + 100*eye(7);


% 2. Работа с ненулевыми элементами разреженных матриц.
% 2.1. Число ненулевых элементов:
nnz(sA1);

% 2.2. Вычисление функций от ненулевых элементов:
spfun(@cos,sA1);

% 2.3. Визуализация разреженной матрицы:
sC1 = sprand(100,100,1/20);
spy(sC1);


% 3. Зачем нужно переупорядочивание.
% 3.1. Создать матрицу с ненулевыми элементами на главной диагонали
% и в последнем столбце и последней строке обычным способом. Матрица
% должна быть симметричной и ПО. Размер матрицы от 5 до 10. Проверить
% визуально правильность созданной матрицы:
% 3.2. Преобразовать матрицу в разреженную:
n = 10;
r1 = 15*sprandsym(n, 1/30, 0.8, 1);
r1(1:n-1,n) = rand(1,n-1);
r1 = tril(r1') + triu(r1,1); %SYMMETRIZE
subplot(2,2,1);
spy(r1);

% 3.3. Применить преобразование Холецкого (chol).
% Визуализировать полученную матрицу.
hol1 = chol(r1);
subplot(2,2,2);
spy(hol1);

% 3.4. Создать матрицу с ненулевыми элементами на главной диагонали
% и в ПЕРВОМ столбце и ПЕРВОЙ строке обычным способом. Матрица должна
% быть симметричной и ПО. Размер матрицы от 5 до 10. Проверить визуально
% правильность созданной матрицы
n = 10;
r2 = 15*sprandsym(n, 1/30, 0.8, 1);
r2(1, 2:n) = rand(1, n-1);
r2 = tril(r2') + triu(r2,1);
subplot(2,2,3);
spy(r2);

% 3.5. Перевести матрицу в разреженную форму, применить преобразование
% Холецкого, визуализировать результат
hol2 = chol(r2);
subplot(2,2,4);
spy(hol2);


% МИНИМУМ (+1)
% 4. Обратный алгоритм Катхилла-Макки.
% 4.1. Создать случайную разреженную матрицу размерности 150
% с плотностью 0,01 (лучше по формуле). Сколько у нее ненулевых элементов?
S = sprand(150, 150, 0.01, 1) + 10*eye(150); 
nonzero = nnz(S); % Ненулевые элементы
subplot(3,2,1), spy(S), title("S = sprand(150)");

% 4.2. Применить разложение Холецкого:
S_chol = chol(S); % для этого была создана ПО матрица в стр. 89
subplot(3,2,2), spy(S_chol), title("chol(S)");

% 4.3. Найти матрицу перестановок по обратному алгоритму Катхилла-Макки:
rkm = symrcm(S);
S_rkm = S(rkm, rkm);
subplot(3,2,3), spy(S_rkm), title("symrcm(S)");

% 4.4. Применить разложение Холецкого:
chol_rkm = chol(S_rkm);
subplot(3,2,4), spy(chol_rkm), title("chol(symrcm(S))");


% 5. Алгоритм минимальной степени
% Проделать аналогичные действия, используя для создания матрицы
% перестановок функцию symamd
sap = symamd(S);
S_sap = S(sap, sap);
subplot(3,2,5), spy(S_sap), title("symamd(S)");

chol_sap = chol(S_sap);
subplot(3,2,6), spy(chol_sap), title("chol(symamd(S))");



% ДОСТАТОЧНО (+1)
% 6. Построить зависимость заполнения множителей разложения Холецкого
% при применении chol к исходной матрице и к матрицам с переставленными
% строками и столбцами при помощи symrcm и symamd.
nonzero1 = [];
nonzero2 = [];
nonzero3 = [];
msize = 80:150;
for n=msize
    M = sprand(n, n, 0.01, 1) + 10*eye(n);
    
    Ch1 = chol(M);
    nonzero1 = [nonzero1 nnz(Ch1)/n^2];
    
    km = symrcm(M);
    nonzero2 = [nonzero2 nnz(chol(M(km, km)))/n^2];
    
    sm = symamd(M);
    nonzero3 = [nonzero3 nnz(chol(M(sm, sm)))/n^2];
end

semilogy(msize, nonzero1,msize, nonzero2,msize, nonzero3)
grid on
legend('Исходная','symrcm','symamd','Location','southeast')
xlabel ('Размерность матрицы')
ylabel('Отношение ненулевых элементов ко всем')


% 7. Что быстрее?
% Определить время работы алгоритма при решения СЛАУ с разложением
% Холецкого без перестановок и с перестановками. Создать цикл по
% плотности заполнения матрицы. Построить график времени от плотности
t1 = [];
t2 = [];
t3 = [];
% density = logspace(-2.5, 0, 150);
density = linspace(0, 1, 150);
msize = 160;
pb = uiprogressdlg(uifigure,'Title','Подождите...')
for d=density
    M = sprand(msize, msize, d, 1) + 10*eye(msize);
    pb.Value = d;
    pb.Message = "Вычлисление для плотности: " + string(d);
    t1 = [t1 timeit(@() chol(M))];
    t2 = [t2 timeit(@() srcm(M))];
    t3 = [t3 timeit(@() samd(M))];
end
close(pb);
plot(density, t1, density, t2, density, t3)
grid on
legend('только Холецкий','symrcm','symamd','Location','south')
title("Сравнение методов")
xlabel('Плотность заполнения матрицы')
ylabel('Время одного вычисления, с')


% МАКСИМУМ (+1)
% 8. Перестроить зависимости заполнения и времени, создав усреднение
% результатов по нескольким матрицам одной размерности и одной
% плотности соответственно
t1 = [];
t2 = [];
t3 = [];
density = logspace(-2, 0, 100);
msize = 100;
N = 15;
pb = uiprogressdlg(uifigure,'Title',"Усреднение по "+string(N)+" результатам")
for d=density
    pb.Message = "Вычлисление для плотности: " + string(d);
    t_1 = [];
    t_2 = [];
    t_3 = [];
    
    for i=1:N
        M = sprand(msize, msize, d, 1) + 10*eye(msize);
        pb.Value = d;

        t_1 = [t_1 timeit(@() chol(M))];
        t_2 = [t_2 timeit(@() srcm(M))];
        t_3 = [t_3 timeit(@() samd(M))];
    end
    
    t1 = [t1 mean(t_1)];
    t2 = [t2 mean(t_2)];
    t3 = [t3 mean(t_3)];
end
close(pb);
plot(density, t1, density, t2, density, t3)
grid on
legend('только Холецкий','symrcm','symamd','Location','south')
titletext = "Сравнение методов, усреднение по "+string(N)+" результатам"
title(titletext)
xlabel('Плотность заполнения матрицы')
ylabel('Время одного вычисления, с')
