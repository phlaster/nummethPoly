\input{settings}
\begin{document}
\include{titlepage}
\clearpage
\pagenumbering{arabic}
\setcounter{page}{2}
\tableofcontents

\clearpage
\section*{Даны два уравнения:}
\begin{align}
    &x^4-x^3-2x^2+3x-3=0\\
    &3e^x=5x+3
\end{align}
\section{Поиск отрезков с корнями алгебраического уравнения}
Пусть для алгебраического уравнения $(1)$ степени $n$ с комплексными коэффициентами $a_i\in\mathbb{C}; i\in \{0, 1, ..., n\}$, записанного в общем виде как:
\[
    a_0z^n+a_1z^{n-1}+...+a_n=0,
\]
для которого $a=\max(|a_1|,...,|a_n|)=3, a'=\max(|a_0|,...,|a_{n-1}|)=3$, по теореме о границе расположения корней алгебраического многочлена его комплексные корни находятся в кольце:
\begin{equation}
    \frac{|a_n|}{a'+|a_n|}\le |z| \le 1+\frac{a}{|a_0|}
\end{equation}
\[
    \frac{3}{3+3}\le |z| \le 1+\frac{3}{1}
\]
\begin{equation}
    \frac{1}{2}\le |z| \le 4.
\end{equation}
Грубо получив кольцо (в геометрическом смысле -- кольцо на комплексной плоскости), пользуясь соответствующей теоремой возможно уточнить местонахождение вещественных корней. В нашем случае, когда коэффициенты действительные, примем $A_1=3$ -- максимальный модуль отрицательного коэффициента; $m_1=1$ -- порядковый (начиная с $0$) номер первого отрицательного коэффициента. Тогда верхняя граница положительных корней определяется в соответствии с теоремой, по формуле:
\begin{equation}
    1 + \sqrt[m]{\frac{A_1}{a_{01}}} = 1 +\frac{3}{1} = 4
\end{equation}
Чтобы найти нижнюю границу, заменим в $(1)$ $x$ на $x^{-1}$:
\begin{equation}
    x^{-4}-x^{-3}-2x^{-2}+3x^{-1}-3=0 \hspace{0.5cm} \implies \hspace{0.5cm}
    3x^4-3x^3+2x^2+x-1=0
    \begin{cases}
        A_2 = 3 \\
        m_2 = 1
    \end{cases}
\end{equation}
Верхняя граница для $x^{-1}:$ $1+\sqrt[m_2]{\frac{A_2}{a_{02}}} = 1 +\frac{3}{3} = 2\implies$ нижняя граница для $x$: $\frac{1}{2}$. То есть положительные корни лежат в промежутке $[0.5\ldots4]$.
По этому же принципу заменим в $(1)$ $x$ на $-x$:
\begin{equation}
    x^4+x^3-2x^2-3x-3=0; \implies
     \begin{cases}
        A_3 = 3 \\
        m_3 = 2
    \end{cases}
\end{equation}
Получим верхнюю границу {\it модуля} возможных отрицательных корней: $1+\sqrt[m_3]{\frac{A_3}{a_{03}}} = 1 +\sqrt[2]{\frac{3}{1}} = 2.73205$
Наконец, в $(1)$ заменим $x$ на $-x^{-1}$:
\begin{equation}
    x^{-4}+x^{-3}-2x^{-2}-3x^{-1}-3=0 \hspace{0.5cm} \implies \hspace{0.5cm}
    3x^4+3x^3+2x^2-x-1=0
    \begin{cases}
        A_4 = 1 \\
        m_4 = 3
    \end{cases}
\end{equation}
Получим {\bf нижнюю} границу {\it модуля} возможных отрицательных корней: $1+\sqrt[m_4]{\frac{A_4}{a_{04}}} = 1 +\sqrt[3]{\frac{1}{3}} = 1.693$. Таким образом:
\begin{equation}
    \begin{matrix}
        \text{Интервал положительных корней:} & [0.5 \ldots 4] \\
        \text{Интервал отрицательных корней:} & [-2.73205 \ldots -1.693]
    \end{matrix}
\end{equation}

\section{Поиск отрезков для уточнения корней уравнений}
\subsection{Алгебраическое уравнение $(1)$:}
Произвольно выберем интервал с положительными корнями и воспользуемся теоремой Штурма:
\begin{tabbing}
    \hspace*{4cm}\= \hspace*{6cm} \= \kill
    \> $f(x) = x^4 - x^3 - 2x^2 + 3x - 3$:\> сама функция $(1)$;\\
    \> $f_1(x) = f'_x(x) = 4x^3 - 3x^2 - 4x + 3$:\> первая производная;\\
    \> $f_2(x) = 1.188x^2-2x+2.813$:\> взятый с обратным знаком остаток от деления $\frac{f(x)}{f_1(x)}$;\\
    \> $f_3(x) = 7.180x+5.850$:\> взятый с обратным знаком остаток от деления $\frac{f_1(x)}{f_2(x)}$;\\
    \> $f_4(x) = -5.231$:\> взятый с обратным знаком остаток от деления $\frac{f_2(x)}{f_3(x)}$.
\end{tabbing}
Согласно теореме, число действительных корней $k$ на отрезке $[c_1 \ldots c_2]$ равно разности между числом $p_1$ перемен знака в последовательности $seq_1=\{f(c1), f_1(c_1), f_2(c_1), f_3(c_1), f_4(c_1)\}$ и числом
$p_2$ перемен знака в последовательности $seq_2=\{f(c_2), f_1(c_2), f_2(c_2), f_3(c_2), f_4(c_2)\}$:
\begin{equation}
    \begin{rcases}
        c_1 =0.5 \\
        c_2 =3
    \end{rcases}
    \longrightarrow
    \begin{rcases}
        seq_1=&\{-2.063, 0.750, 2.110, 9.440, -5.231\} \\
        seq_2=&\{42, 72, 7.505, 27.390, -5.231\}
    \end{rcases}
    \longrightarrow
    \begin{rcases}
        p_1=2 \\
        p_2=1
    \end{rcases}
    \longrightarrow
    k=p_1-p_2=1
\end{equation}
То есть на участке $[0.5 \ldots 4]$ находится единственный корень (кратные корни на этом участке отсутствуют, т.к. последний член последовательностей $seq_i$:  $f_4(x)=const$).

\clearpage
\subsection{ Трансцендентное уравнение $(2)$:}
Представим $(2)$ в виде $\psi(x)=\varphi(x)$, построим отдельно кривые $\psi(x)=0$ и $\varphi(x)=0$:
\begin{figure}[H]
    \centering
    \caption{Графическое отделение корней трансцендентного уравнения.}
    \label{fig:pic1}
    \includegraphics[width=1\linewidth]{pic1}
\end{figure}
Искомые корни находятся в точках пересечения этих кривых. Для исследования возьмём (выбранный произвольно) промежуток содержащий один из корней:
\begin{align}
    [0.6 \ldots 1.5]
\end{align}

\clearpage
\section{Численное решение уравнений}
\subsection{Решение уравнений функцией Matlab \texttt{fzero}:}
\texttt{fzero} использует комбинированный подход с использованием метода Ньютона, метода простых итераций и МПД. Судя по источникам, метод Ньютона как самый быстро сходящийся используется в первую очередь. Если с ним возникают проблемы, подключаются менее быстрые и менее же привередливые методы.

\begin{lstlisting}[language=Octave]
% Polynomial function
f1 = @(x) polyval([1,-1,-2,3,-3], x);
X1_0 = [-2.732, -1.693];
X1 = fzero(f1, X1_0);
sprintf('Exact root on chosen interval: %.15f', X1)
\end{lstlisting}
{\singlespacing
\begin{verbatim}
ans =

    'Exact root on chosen interval: -1.732050807568877'
\end{verbatim}}
\begin{lstlisting}[language=Octave, firstnumber=6]
% Transcendental function
f2 = @(x) 3*exp(x) + polyval([-5, -3], x);
X2_0 = [0.6, 1.5];
X2 = fzero(f2, X2_0);
sprintf('Exact root on chosen interval: %.15f', X2)
\end{lstlisting}
{\singlespacing
\begin{verbatim}
ans =

    'Exact root on chosen interval: 0.947404881615151'
\end{verbatim}}
\begin{lstlisting}[language=Octave, firstnumber=11]
% Root for interval, where Newton method conditions violate
X1_ERR = [0.5, 4];
X3 = fzero(f1, X1_0);
sprintf('Exact root on chosen (unappropriate) interval: %.15f', X3)
\end{lstlisting}
{\singlespacing
    \begin{verbatim}
ans =

    'Exact root on chosen (unappropriate) interval: -1.732050807568877'
\end{verbatim}}

\subsection{Метод  Половинного Деления (МПД, метод биекции):}
\begin{enumerate}
    \item Задать отрезок для приближения: $[a, b]$, выбрать желаемую точность: $\varepsilon$;
    \item Проверить условия применимости метода: $f(x)$ непрерывна на $[a, b]$ и имеет на нём единственный корень;
    \item $c:=\frac{a+b}{2};$
    \item Если $|a-c|\le\varepsilon\implies \widetilde{x}:=c\implies\blacksquare$
    \item Если $sign(f(a)) \ne sign(f(c))\implies b:=c$, иначе $a:=c$;
    \item Вернуться к 3.
\end{enumerate}
{\bf Все выбранные отрезки: (9), (11) удовлетворяют условиям метода.}

\subsection{Метод  Ньютона (касательных):}
\begin{enumerate}
    \item Задать отрезок для приближения: $[a, b]$, выбрать желаемую точность: $\varepsilon$;
    \item Проверить условия применимости метода:
        \begin{itemize}
            \item $f \in C^2$
            \item $f'_x(x)$ не обращается в нуль на $[a, b]$;
            \item $f''_{xx}(x)$ ограничена на $[a, b]$;
        \end{itemize}
    \item Выбрать константы $\forall x \in [a,~ b]$:
        \begin{itemize}
            \item $\alpha: ~ |f'(x)|\ge\alpha>0$ -- наименьшее по модулю значение первой производной на отрезке
            \item $\beta: ~ |f''(x)|\le\beta<\infty$  -- наибольшее по модулю значение второй производной на отрезке
        \end{itemize}
    \item Выбрать на отрезке начальное приближение $x_0: f(x_0)\cdot f''_{xx}(x_0) > 0$;
    \item Вычислить $x_{k+1}=x_k-\frac{f(x_k)}{f'_x(x_k)}$
    \item Если $\frac{\beta}{2\alpha}|x_{k+1}-x_k|^2\le\varepsilon
    \implies \widetilde{x}:=x_{k+1}\implies\blacksquare$;
    \item Вернуться к 4.
\end{enumerate}
Рассмотрим имеющиеся интервалы функций (1), (2)...
\begin{figure}[H]
    \centering
    \caption{Интервалы нахождения корней, полученные из применения теоремы о верхней границы.}
    \label{fig:pic2}
    \includegraphics[width=1\linewidth]{pic2}
\end{figure}
Из графиков очевидно, что положительный интервал функции (1) не удовлетворяет условиям применимости метода Ньютона, т.к. первая производная функции не отделена от нуля.
\clearpage
\subsection{Применение алгоритмов к трансцендентной функции (2) на допустимом интервале:}
\subsubsection{МПД:}
\begin{itemize}
    \item $[a, b]=[0.6, 1.5]$;
    \item $c=\frac{a+b}{2}=1.05;$
    \item $|a-c|=\mathbf{0.45}$;
    \item $f(a)\cdot f(c)<0\implies b:=1.05$;
    \item $c=\frac{a+b}{2}=0.825;$
    \item $|a-c|=\mathbf{0.225}$;
    \item $f(a)\cdot f(c)>0\implies a:=0.825$;
    \item $c=\frac{a+b}{2}=0.9375;$
    \item $|a-c|=\mathbf{0.1125}$;
    \item $f(a)\cdot f(c)>0\implies a:=0.9375$;
    \item $c=\frac{a+b}{2}=0.99375;$
    \item $|a-c|=\mathbf{0.05625}$;
    \item и т.д. Заметим, что на каждом шаге точность равномерно возрастает.
\end{itemize}

\subsubsection{Метод Ньютона:}
\begin{itemize}
    \item $[a, b]=[0.6, 1.5]$;
    \item $\alpha = \inf\limits_{x \in [a,b]}(\left\{ |f'(x)|\right\}) = |f'(a)| = f'(0.6) = \mathbf{0.4664}$
    \item $\beta = \sup\limits_{x \in [a,b]}(\left\{ |f''(x)|\right\}) = |f''(b)| = f''(1.5) = \mathbf{13.4451}$
    \item $f(b)\cdot f''_{xx}(x_0) > 0 \implies x_0 := b = 1.5;$
    \item $x_1 := x_0 - \frac{f(x_0)}{f'_x(x_0)} = 1.5 - \frac{2.9451}{8.4451} = 1.15127$
    \item $\frac{\beta}{2\alpha}|x_1-x_0|^2 = 14.415 \cdot 0.3487^2 = \mathbf{1.7531}$
    \item $x_2 := x_1 - \frac{f(x_1)}{f'_x(x_1)} = 1.15127 - \frac{0.73027}{4.48662} = 0.9885$
    \item $\frac{\beta}{2\alpha}|x_2-x_1|^2 = 14.415 \cdot 0.1628^2 = \mathbf{0.3819}$
    \item $x_3 := x_2 - \frac{f(x_2)}{f'_x(x_2)} = 0.9885 - \frac{0.1191}{3.0616} = 0.9496$
    \item $\frac{\beta}{2\alpha}|x_3-x_2|^2 = 14.415 \cdot 0.0389^2 = \mathbf{0.02182}$
    \item и т.д. Заметим, что на каждом шаге точность равномерно возрастает.
\end{itemize}

\clearpage

\section{Построить зависимости числа итераций от заданной точности:}
\subsection{Matlab \texttt{fzero}}
\subsubsection{Код программы}
\begin{lstlisting}[language=Octave, firstnumber=15]
n_iters_1 = zeros(1, 15);
n_iters_2 = zeros(1, 15);
epsilon = zeros(1, 15);
for i = 1:15
    epsilon(i) = 10^(-i);
    options = optimset(tolX=epsilon(i));
    [~, ~, ~, output_1] = fzero(f1, X1_0, options);
    [~, ~, ~, output_2] = fzero(f2, X2_0, options);
    n_iters_1(i) = output_1.iterations;
    n_iters_2(i) = output_2.iterations;
end
semilogx(eps, n_iters_1, 'red');
hold on; grid on;
semilogx(eps, n_iters_2, 'blue');
xlabel('eps'); ylabel('N iters'); title('fzero'); legend("f1", "f2");
saveas(gcf, 'fzero.png'); hold off;
\end{lstlisting}
\subsubsection{График зависимости}
\begin{figure}[H]
    \centering
    \caption{Зависимость скорости сходимости функции \texttt{fzero} от заданной точности для алгебраической и трансцендентной функций.}
    \label{fig:pic3}
    \includegraphics[width=0.85\linewidth]{fzero}
\end{figure}

\clearpage

\subsection{C++ МПД:}
\subsubsection{Код программы}
\begin{lstlisting}[language=c++]
double f1  (double x){ return    pow(x, 4) -   pow(x, 3) - 2*pow(x, 2) + 3*x - 3; }
double f1d1(double x){ return 4 *pow(x, 3) - 3*pow(x, 2) - 4*x + 3; }
double f1d2(double x){ return 12*pow(x, 2) - 6*x - 4; }
double f2  (double x){ return 3 *exp(x)    - 5*x - 3; }
double f2d1(double x){ return 3 *exp(x)    - 5; }
double f2d2(double x){ return 3 *exp(x); }

ans bisection(double (*f)(double), double exact, Vec lims, double eps){
    double a = lims[0], b = lims[1], c;
    int nSteps = 1;
    for(;;){
        c = (a+b)/2;
        if (fabs(a-c) <= eps)
            return ans({c, fabs(exact-c), nSteps});
        if (f(a) * f(c) > 0)
            b = c;
        else
            a = c;
        nSteps++;
    }
}
\end{lstlisting}
\subsubsection{Графики зависимостей}
\begin{figure}[H]
    \centering
    \caption{Зависимость скорости сходимости МПД и его фактической ошибки от заданной точности для алгебраической и трансцендентной функций.}
    \label{fig:pic4}
    \includegraphics[width=1\linewidth]{mpd}
\end{figure}

\clearpage

\subsection{C++ Метод Ньютона:}
\subsubsection{Код программы}
\begin{lstlisting}[language=c++, firstnumber=22]
ans newton(double (*f)(double), double exact, Vec lims, double eps){
    auto d1 = (f==f1) ? f1d1 : f2d1;
    auto d2 = (f==f1) ? f1d2 : f2d2;
    double a = lims[0], b = lims[1];
    double x0 = (f(a)*d2(a) > 0) ? a : b;
    double alpha = min(fabs(d1(a)), fabs(d1(b)));
    double beta  = max(fabs(d2(a)), fabs(d2(b)));
    int nSteps = 1;
    for (;;){
        double x_n = x0 - f(x0)/d1(x0);
        double delta = fabs(x_n-x0);
        if (beta/alpha/2 * delta * delta <= eps)
            return ans({x_n, fabs(exact-x_n), nSteps});
        x0 = x_n;
        nSteps++;
    }
}
\end{lstlisting}
\subsubsection{Расчётные константы}
\begin{equation}
\begin{matrix}
    f_1: & [a_1,b_1] =\mathit{[-2.732, -1.693]} &\alpha_1=|f'(b_1)|=\mathbf{18.237} &\beta_1=|f''(a_1)|=\mathbf{101.958}; \\
    f_2: & [a_2,b_2] =\mathit{[0.6, 1.5]} &\alpha_2=|f'(a_2)|=\mathbf{0.4664} &\beta_2=|f''(b_2)|=\mathbf{13.4451};
\end{matrix}
\end{equation}
\subsubsection{Графики зависимостей}
\begin{figure}[H]
    \centering
    \caption{Зависимость скорости сходимости метода Ньютона и его фактической ошибки от заданной точности для алгебраической и трансцендентной функций.}
    \label{fig:pic5}
    \includegraphics[width=1\linewidth]{newton}
\end{figure}

\clearpage

\section{Сходимость метода при нарушении условий применимости:}
Для демонстрации изменения сходимости метода Ньютона при нарушении условий применимости достаточно взять найденный  для алгебраического полинома (1) положительный интервал содержащий корень. На нём, как было показано, нарушается условие отделённости первой производной от нуля. Также, дополнительно нарушим условие $sign(f(x_0))=sign(f''(x_0))$ для начального приближения, выбрав на Рис.2 <<на глаз>> точку $x_0=1.1$, где знаки функции и её второй производной противоположны.
\subsection{Код программы}
\begin{lstlisting}[language=c++, firstnumber=39]
ans newton_broken(double exact, Vec lims, double x0, double eps){
    double a = lims[0], b = lims[1]; int nSteps = 1;
    double alpha = min(fabs(f1d1(a)), fabs(f1d1(b)));
    double beta  = max(fabs(f1d2(a)), fabs(f1d2(b)));
    for (;;){
        double x_n = x0 - f1(x0)/f1d1(x0);
        double delta = fabs(x_n-x0);
        if (beta/alpha/2 * delta * delta <= eps)
            return ans({x_n, fabs(exact-x_n), nSteps});
        x0 = x_n;  nSteps++;
}   }
\end{lstlisting}
\subsubsection{Использованные константы}
\begin{equation}
    f_1: ~ [a,b] =\mathit{[0.5, 4]}; ~ \alpha=|f'(a)|=\mathbf{0.75}; ~ \beta=|f''(b)|=\mathbf{164}; ~ \text{Без нарушения: }x_0=\mathbf{0.5}; ~ \text{Нарушение: }x_0=\mathbf{1.1}
\end{equation}
\subsection{Графики}
\begin{figure}[H]
    \centering
    \caption{Зависимость скорости сходимости и фактической ошибки метода Ньютона от заданной точности при нарушении условий применимости метода.}
    \label{fig:pic6}
    \includegraphics[width=0.95\linewidth]{broken_newton}
\end{figure}
\subsection{Комментарий}
Из графиков следует, что при нарушении условия применимости метода количество итераций до схождения метода увеличивается. Также, хотя в данном случае метод сошёлся корректно, невозможно заранее знать, сойдётся ли метод к корню на выбранном интервале, к корню снаружи интервала или же вовсе будет расходиться. Метод Ньютона, хотя и выгодно отличается по порядку сходимости от метода половинного деления, требует особого внимания к соблюдению условий его применимости.

\section{Модульная структура программы}
\subsection{Заголовочный файл \texttt{functions.hpp}:}
\begin{lstlisting}[language=c++]
#include <cmath>
#include <vector>
using namespace std; using Vec = vector<double>;
struct ans {
    double root;
    double absErr;
    int nSteps;
};
double f1(double x);    double f2(double x);
double f1d1(double x);  double f2d1(double x);
double f1d2(double x);  double f2d2(double x);

ans bisection(double (*f)(double), double exact, Vec lims, double eps);
ans newton(double (*f)(double), double exact, Vec lims, double eps);
ans newton_broken(double exact, Vec lims, double x0, double eps);

void errorConverg(double exact, Vec interval,
                  ans    (*method)(double (*f)(double), double, Vec, double),
                  double (*f)     (double),
                  string filename);
void brokenConverg(double exact, double x0, Vec lims, string filename);
\end{lstlisting}
\subsection{Точка входа \texttt{main.cpp}:}
\begin{lstlisting}[language=c++]
#include "functions.hpp"
const Vec F1_INTERVAL = {-2.732, -1.693},  F2_INTERVAL = {0.6, 1.5};
const double X1 = -1.732050807568877, X2 = 0.947404881615152, X3 = 1.732050807568877;

void main(){
    errorConverg(X1, F1_INTERVAL, bisection, f1, "bisect1.csv");
    errorConverg(X2, F2_INTERVAL, bisection, f2, "bisect2.csv");

    errorConverg(X1, F1_INTERVAL, newton, f1, "newton1.csv");
    errorConverg(X2, F2_INTERVAL, newton, f2, "newton2.csv");

    brokenConverg(X3, 0.5, {0.5,4}, "broken_newton(limits).csv");
    brokenConverg(X3, 1.1, {0.5,4}, "broken_newton(limits+x0).csv");
}
\end{lstlisting}
\end{document}